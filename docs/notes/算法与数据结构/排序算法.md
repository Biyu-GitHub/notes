# 排序算法

## 排序算法的比较

| 算法             | 稳定性 | 时间复杂度                   | 空间复杂度 | 备注                     |
| ---------------- | ------ | ---------------------------- | ---------- | ------------------------ |
| 选择排序         | ×      | N<sup>2</sup>                | 1          |                          |
| 冒泡排序         | √      | N<sup>2</sup>                | 1          |                          |
| 插入排序         | √      | N ~ N<sup>2</sup>            | 1          | 时间复杂度和初始顺序有关 |
| 希尔排序         | ×      | N 的若干倍乘于递增序列的长度 | 1          | 改进版插入排序           |
| 快速排序         | ×      | NlogN                        | logN       |                          |
| 三向切分快速排序 | ×      | N ~ NlogN                    | logN       | 适用于有大量重复主键     |
| 归并排序         | √      | NlogN                        | N          |                          |
| 堆排序           | ×      | NlogN                        | 1          | 无法利用局部性原理       |

## 选择排序

从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。

```java
public class Selection{
    public void sort(int[] nums) {
        int N = nums.length;
        
        for(int i = 0; i < N - 1; i++) {
            int minIndex = i;
            
            for(int j = i + 1; j < N; j++) {
                if(nums[j] < nums[j-1])
                    minIndex = j;
            }
            
            swap(nums, i, minIndex);
        }
    }
}
```

## 冒泡排序

从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。

在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。

```java
public class Bubble {
    public void sort(int[] nums) {
        int N = nums.length;
        boolean isSorted = false;
        
        for(int i = 0; i < N && !isSorted; i++) {
            isSorted = true;
            for(int j = 0; j < N - i - 1; j++) {
                if(nums[j] > nums[j + 1])
                    isSorted = false;
                    swap(nums, j, j+1);
            }
        }
    }
}
```

## 插入排序

每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。

```java
public class Insertion {
    public void sort(int[] nums) {
        int N = nums.length;
        for(int i = 1; i < N; i++) {
            for(int j = i; j > 0; j--) {
                if(nums[j] < nums[j - 1])
                    swap(nums, j, j - 1);
            }
        }
    }
}
```

## 希尔排序

希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。

```java
public class Shell {
    public void sort(int[] nums) {
        int N = nums.length;
        int h = 1;
        
        while(h < N / 3)
            h = h * 3 + 1;
        
        while(h > 0) {
            for(int i = h; i < N; i++) {
                for(int j = i; j -h >= 0; j--) {
                    if(nums[j] < nums[j - h])
                        swap(nums, j, j - h);
                }
            }
            
            h = h / 3;
        }
    }
}
```

## 归并排序

### 1.1 归并方法

1. 归并方法将数组中两个已经排序的部分归并成一个。
2. 首先将数组整体复制到一个辅助数组中
3. 约定l指向第一个元素，h指向最后一个元素

<img src="../img/MergeSort.png">归并方法</img>

```java
public abstract class MergeSort {
    private int[] aux;
    
    public void merge(int[] nums, int l, int m, int h) {
        int i = l;
        int j = m + 1;
        
        for(int k = 0; k <= h; k++)
            aux[k] = nums[k];
        
        for(int k = l; k <= h; k++) {
            if(i > m) nums[k] = aux[j++];
            else if(j > h) nums[k] = aux[i++];
            else if(aux[i] < aux[j]) nums[k] = aux[i++];
            else nums[k] = aux[j++];
        }
    }
}
```

### 2. 自顶向下归并排序

```java
public class Up2DownMergeSort extends MergeSort{
    
}
```



## 堆排序

### 1 二叉堆的基本结构

1. 二叉堆是一颗完全二叉树，可以使用数组存储。
2. （最大堆）中某个节点的值总是不大于其父亲节点的值（相应的可以定义最小堆）。

### 2 获取索引

* 求父亲节点索引

```java
private int parent(int index){
    if(index == 0)
        throw new IllegalArgumentException("index-0 doesn't have parent.");
    return (index - 1) / 2;
}
```

* 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引

```java
private int leftChild(int index){
    return index * 2 + 1;
}
```
* 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引

```java
private int rightChild(int index){
    return index * 2 + 2;
}
```

### 3 添加与上浮

添加元素至末尾，如果大于其父亲节点，则元素需要上浮。

* 添加元素

```java
public void add(E e){
    data.addLast(e);
    siftUp(data.getSize() - 1);
}
```

* 上浮

```java
private void siftUp(int k) {
    while(k > 0 && data.get(parent(k)).compareTo(data.get(k)) < 0) {
        data.swap(k, parent(k));
        k = parent(k);
    }
}
```

### 4 取出最大元素与下沉

最大元素为根节点，取出后，用末尾元素替代，如果小于其子节点，则元素进行下沉操作。**下沉操作是与两个子节点中最大的元素交换**。

* 查看堆中的最大元素

```java
public E findMax(){
    if(data.getSize() == 0)
        throw new IllegalArgumentException("Can not findMax when heap is empty.");
    return data.get(0);
}
```

* 取出堆中最大元素

```java
public E extractMax() {
	E ret = findMax();
    data.swap(0, data.getSize() - 1);
    data.removeLast();
    siftDown(0);

    return ret;
}
```

* 下沉

```java
private void siftDown(int k){
	while(leftChild(k) < data.getSize()) {
        int j = leftChild(k);
        // 让j指向左右孩子中较大的元素
        if( j + 1 < data.getSize() && data.get(j + 1).compareTo(data.get(j)) > 0 )
            j ++;
        // 如果父节点大于孩子节点，则结束循环
        if(data.get(k).compareTo(data.get(j)) >= 0 )
        	break;
        data.swap(k, j);
        k = j;        
    }
}
```

### 5 堆排序算法

1. 建立最大堆：
   * 从数组中间的位置，往前遍历每个元素，进行下沉操作。
   * 因为叶子节点占整个数量的一半，且叶子节点不需要下沉。
2. 交换根节点元素：
   * 最大堆建立完成后，根节点元素最大，此时将其与末尾元素交换，则该元素有序。
3. 再次进行下沉操作：
   * 此时根节点为原来的末尾元素，对该元素进行下沉操作。
   * 即在此建立最大堆。
4. 重复以上步骤，直到堆中只剩下一个元素。

* [**数据结构排序算法之堆排序演示**](<https://www.bilibili.com/video/av18980178?from=search&seid=11058036500818831977>)



## LeetCode

* [**347. Top K Frequent Elements**](https://leetcode.com/problems/top-k-frequent-elements/description/)
