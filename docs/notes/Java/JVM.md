# JVM

##  Runtime Data Area

> * **程序计数器：**记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
>
> * **Java虚拟机栈：**每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
>   
>   * 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
> * 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。
>   
> * **本地方法栈：**本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
>
> * **堆：**所有对象都在这里分配内存，是**垃圾收集**的主要区域（"GC 堆"）。
>
> * **方法区：**用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。对这块区域进行垃圾回收的主要目标是对常量池的回收和对**类的卸载**，但是一般比较难实现。
>
>   > 方法区也被称为永久代，永久代是HotSpot虚拟机实现方法区的一种方法
>   >
>   > 1.8 将方法区移至元空间
>
> * **运行时常量池：**运行时常量池是方法区的一部分。
>
>   > 1.7 以后将常量池移动到堆区
>
> * **直接内存：**在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。

## GC

### 判断对象是否可以被回收

> * **引用计数法：**为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
>   * **循环引用问题**
> * 可达性分析算法：以**GC Roots**为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。
>   * **GC Roots**
>     * 虚拟机栈中局部变量表引用的对象
>     * 本地方法栈中JNI引用的对象
>     * 方法区中静态类属性引用的变量
>     * 方法区中常量引用的对象
>     * 活跃线程引用的对象

### 类的卸载条件

> * 该类所有的实例都已经被回收。
> * 加载该类的 ClassLoader 已经被回收。
> * 该类对应的 Class 对象没有在任何地方被引用。

### 引用类型

> * 强引用：被强引用关联的对象不会被回收，使用new创建。
> * 软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。
> * 弱引用：一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
> * 虚引用：为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

### 垃圾收集算法

#### 标记-清除

> * 标记阶段标记存活对象，回收阶段回收对象并取消标记位。将回收的空间加入到空闲链表中，空闲链表是一个单向链表
> * 缺点：
>   * 标记和清除效率低
>   * 产生大量不连续的内存碎片，导致无法分配内存给大对象

#### 标记-整理

> * 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
> * 不会产生内存碎片，但是需要移动大量对象，处理效率比较低。

#### 复制

> * 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。
> * 主要不足是只使用了内存的一半。

#### 分代收集

> * 新生代：复制算法
> * 老年代：标记清除或标记整理

#### 垃圾收集器

> * **Sreial：**单线程收集器，简单高效，在单个CPU环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。**Client**默认新生代收集器
> * **ParNew：**Sreial多线程版本，**Server**默认新生代收集器，除了Serial只有它能与CMS配合使用
> * **Parallel Scavenge：**其它收集器目标是尽可能**缩短垃圾收集时用户线程的停顿时间**，而它的目标是达到一个可控制的吞吐量，因此它被称为“**吞吐量优先**”收集器。
> * **Serial Old：** 用于Client，如果用于Server，则是为了和其他两个搭配使用
> * **Parallel Old：**
> * **CMS**
>   * **步骤：**
>     * 初始标记：停顿，速度快，仅标记GCRoots直接
>     * 并发标记
>     * 重新标记
>     * 并发清除
>   * **缺点：**
>     * 吞吐量低
>     * 无法处理浮动垃圾（并发清除阶段产生的垃圾），而由于存在浮动垃圾，就需要预留出一部分空间，而不能等到老年代快满的时候再进行垃圾回收。当预留空间不足的时候，会出现Concurrent Mode Failure，这时候启用Serial Old来代替CMS。
>     * 标记清除会产生内存碎片，提前触发Full GC
> * **G1：**可以对新生代和老年代一起进行回收。把堆划分成多个大小相等的独立区域，使得新生代和老年代不再物理隔离。可以维护一个优先列表记录回收时间与获得的空间，每次先回收价值最大的区域。
>   * 步骤
>     * 初始标记
>     * 并发标记
>     * 最终标记
>     * 筛选回收

## 内存分配与回收

### 对象空间分配策略

> * 优先分配Eden区，如果空间不足，发起Minor GC
> * 大对象直接进入老年代，例如数组以及很长的字符串
> * 长期存活对象进入老年代，活过一次Minor GC对象的年龄+1，默认15岁进入老年代
> * 动态年龄判断：如果相同年龄对象所占空间的大小超过Survivor的一半，则进入老年代
> * 空间分配担保：MinorGC之前，检查老年代剩余空间是否大于新生代所有对象的总和。
>   * 是的话，则代表Minor GC是安全的。
>   * 否的话查看是否允许担保失败：
>     * 允许：检查剩余空间是否大于之前历次进入到老年代的对象的空间大小
>       * 是：尝试进行一次Minor GC
>       * 否：Full GC
>     * 不允许：Full GC

### Full GC的触发条件

> * 调用System.gc()，建议执行垃圾回收，但不一定执行
> * 老年代空间不足
> * 空间分配担保失败
> * 使用CMS收集器发生Concurrent Mode Failure

### 对象的创建过程

> * 类加载检查：检查类是否加载完成，否则执行类的加载
> * **分配内存：**取决与内存是否规整，取决于垃圾收集方法
>   * 指针碰撞：标记整理算法：指针指向临界区，只需要向空闲方向移动指针即可
>   * 空闲列表：标记清除算法
>   * 并发分配内存问题：
>     * CAS + 失败重试：乐观锁
>     * TLAB：为每个线程预先再Eden中分配一块内存，当剩余空间不足时再采用CAS
> * 初始化0值
> * 设置对象头
> * 执行init方法

## 类加载机制

### 生命周期

> 加载，验证，准备，解析，初始化，使用，卸载

### 加载过程

> * 加载：通过全限定类名加载二进制字节流；将结构转换为方法区的运行时数据结构；生成class对象
> * 验证：验证class字节流中包含的信息符合当前JVM的规范，并且不会造成危害
> * 准备：给类的静态成员分配空间，并设置初始值；如果是静态常量，则直接赋值；而实例变量则是在对象创建的时候在堆内存中分配空间。
> * 解析：将常量池中的符号引用替换为直接引用
> * 初始化：执行类的初始化过程

### 类的初始化时机

> * 主动引用：
>   * new
>   * 反射调用
>   * 初始化一个类的时候，如果其父类没有初始化，则进行父类的初始化
>   * 虚拟机启动时会初始化主类
> * 被动引用：所有引用类的方式都**不会触发初始化**，称为被动引用
>   * 通过子类引用父类的静态字段
>   * 创建类的数组
>   * 直接调用父类的常量

### 类加载器

> * 从JVM角度：启动类加载器，其他类加载器
> * 从开发者角度：
>   * 启动类加载器-BootStrap ClassLoader：lib
>   * 扩展类加载器-Extension ClassLoader：lib/ext
>   * 应用程序类加载器-Application ClassLoader：程序中默认的类加载器
>   * 用户自定义类加载器

### 双亲委派模型

> 说明：首先将类加载请求转发给父加载器，当其无法完成时，再尝试自己加载。
>
> 好处：使得基础类得到统一。例如自己编写了java.lang.Object，可以编译通过，但是无法加载，保证加载的Object为相同的。

### 自定义类加载器

> * 继承ClassLoader
> * 重写findClass方法，使其读取自定义类路径上的字节码文件，并返回字节数组

### class.forname和ClassLoader.loadClass的区别

> * forName是初始化之后的
> * loadClass是没链接的

#### JVM三大性能调优参数

> * -Xss：设置每个线程虚拟机栈的大小
> *  -Xms：堆的初始值
> *  -Xmx：堆的最大值
