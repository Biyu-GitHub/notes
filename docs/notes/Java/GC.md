# GC

## 对象被判定为垃圾的标准？

没有被其他对象引用

## 判断对象是否为垃圾的算法？

* 引用计数法
* **可达性分析算法**

### 引用计数法

* **说明：**
  * 通过判断对象的引用数量来决定对象是否可以被回收
  * 每个对象实例都有一个引用计数器，被引用+1，完成引用-1
  * 任何引用计数为0的对象实例都可以被当作垃圾收集

* **优点：**
  * 执行效率高，程序执行受影响较小
* **缺点：**
  * 无法检测出循环引用的情况，导致内存泄漏

### 可达性分析算法

* 说明：
  
* 通过判断对象的引用链是否可达来决定对象是否可以被回收
  
* 可以作为GC Root的对象

  * 虚拟机栈中引用的对象（栈帧中的本地变量表）
  * 方法区中的常量引用的对象
  * 方法区中的类静态属性引用的对象
  * 本地方法中JNI（Native方法）的引用对象
  * 活跃线程的引用对象

  > JNI是Java Native Interface的缩写

## 谈谈你了解的垃圾回收算法？

### 标记-清除算法（Mark and Sweep）

* 标记：从根集合扫描，对存活的对象进行标记
* 清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存

* 特点：导致内存碎片化

### 复制算法（Copying）

* 分为对象面和空闲面
* 对象在对象面上创建
* 存活的对象从对象面复制到空闲面
* 将对象面的所有对象内存清除

![GC_复制算法](..\images\GC\GC_复制算法.jpg)

* 特点：

  * 解决碎片化问题
  * 顺序分配内存，简单高效
  * 适用于对象存活率低的场景

  > 用于新生代，对象存活率不足10%

### 标记-整理算法（Compacting）

* 标记：从根集合扫描，对存活的对象进行标记
* 整理：移动所有存活的对象，且按照内存地址依次排列，将末端内存地址以后的内存全部回收

* 特点：

  * 避免内存的不连续
  * 不用设置两块内存互换
  * 适用于对象存活率高的场景

  > 例如老年代

### 分代收集算法（Generational Collector）

* 垃圾回收算法的组合拳
* 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
* 目的：提高JVM的回收效率

![GC_对象区域划分](..\images\GC\GC_对象区域划分.jpg)

#### GC的分类

* Minor GC（新生代）
* Full GC（老年代的垃圾回收通常伴随新生代的垃圾回收，所以叫做Full GC）

#### 年轻代

* 尽可能快速地收集掉那些生命周期短地对象
  * Eden区（伊甸园，出生地地方）
  * 2个Survivor区（幸存区）

![GC_年轻代分区](..\images\GC\GC_年轻代分区.jpg)

* 年轻代垃圾回收动画演示

![年轻代垃圾回收动画演示](..\images\GC\GC_MinorGC.gif)

#### 对象如何晋升到老年代？

* 经历一定Minor次数依然存活的对象（默认15岁）
* Survivor中存放不下的对象
* 新生成的大对象（使用`-XX:+PretenuerSizeThreshold`指定大小）

#### 常用调优参数？

* `-XX:SurviverRatio`：Eden：Survivor，默认8：1
* `-XX:NewRatio`：老年代：新生代
* `-XX:MaxTenuringThreshold`：对象晋升老年代的GC最大次数

#### 老年代

* 采用**标记-清理**和**标记-整理**算法

* Full GC速度慢，但是频率低

#### 触发Full GC的条件？

* 老年代空间不足
* 永久代空间不足
* CMS GC时出现promotion failed，concurrent mode failure（了解）
* Minor GC晋升到老年代的平均大小大于拉年代的剩余空间
* 调用System.gc()（不一定执行，只是建议）
* 使用RMI来进行RPC或管理的应用，每小时执行1次Full GC

### Stop-the-World

* JVM由于要执行GC而停止了应用程序的执行
* 任何一种GC算法中都会发生
* 多数GC优化铜鼓减少Stop-the-world发生的时间来提高程序性能

### Safepoint

* 分析过程中对象引用关系不会发生变化的点
* 产生Safepoint的地方：方法调用，循环跳转，异常跳转灯
* 安全点数量需要适中